
┌───────────────────────┐
     T3 Template 🚀🎸   
└───────────────────────┘

Elements

	✔ T3 App
	✔ Supabase
	✔ Authentication
	✔ Auth UI
	✔ Dark Mode
	✔ Color Theme
	✔ Custom Font
	✔ Sitemap
	✔ Stripe
	✔ Form Input
	✖ Tinybird
	✖ Sentry
	✖ MJML Mail Service
	✖ Zustand

____________________________________________________________________

Method

- npm create t3-app@latest

Merge Template:
- merge /Template files

Dependencies:
- npm i @supabase/supabase-js @supabase/auth-helpers-react @supabase/auth-helpers-nextjs @supabase/auth-ui-react @supabase/auth-ui-shared
- npm i micro stripe next-themes next-sitemap react-tailwindcss-select @heroicons/react @headlessui/react clsx
- npm i stripe @stripe/stripe-js

Forms: 
- npm install react-hook-form zod @hookform/resolvers @radix-ui/react-slot @radix-ui/react-label @radix-ui/react-select @radix-ui/react-popover @radix-ui/react-dialog tailwind-merge class-variance-authority cmdk

Types:
- npm i supabase@">=1.8.1" --save-dev
- npm i --save-dev stripe-event-types ts-toolbelt @total-typescript/ts-reset

- barrel export all routers (right click folder)
- npx supabase login
- n sb

- replace favicon, logo in public
- adjust tailwind theme in config file

External Services:
- make new supabase project
- make Supabase tables, functions, triggers, webhooks
	tables: billing (auth_id, auth_email, stripe_customer_id)
	functions (table/server->plpgsql): make billing profile
	webhooks (table->api): add stripe customer

- set auth providers at app.supabase.com/project/.../auth/providers
- make the app on the provider platform
	- https://console.cloud.google.com/home/dashboard
	- https://developer.twitter.com/en/portal/projects/1515098723440803842/apps
	- https://github.com/settings/applications/new
	- create oAuth client ID https://console.cloud.google.com/apis/credentials?project=
	- set authorised and redirect urls on client
	- publish app OAuthConsent screen
- set supabase client id and secret
- set authorised url to localhost on supabase auth url config: app.supabase.com/project/srvugcsqhomwbephgagd/auth/url-configuration

- Make Stripe products, webhooks, add Env vars with price ID

- set env variables

- Add a tailwind template

Extra: npm i react-parallax-tilt (Tweet)


You're all done!


____________________________________________________________________


TABLES
billing (auth_id, auth_email, stripe_customer_id)


FUNCTIONS
make_billing_profile:

begin
  insert into public.billing(auth_id, auth_email)
  values(new.id, new.email);

  insert into public.keys(auth_id)
  values(new.id);

  return new;
end

WEBHOOKS
add-customer-on-stripe:

url: /api/webhooks/supabase
content-type: application/json
http params: WEBHOOK_SECRET = <generated> , TRIGGER_PROCESS = create-stripe-customer


____________________________________________________________________


STRIPE:
1. Create Products
2. Create Webhook Endpoint on Stipe dashboard (url: /api/webhooks/stripe)
3. Set API and Webhook keys in env

____________________________________________________________________



Deploy Time Config
1. edit next-sitemap.config.js, server-sitemap.xml/index.ts to appropriate routes
2. Google/OAuth provider origin url/redirect url/logo/verification
3. Stripe webhook urls
4. Supabase webhook urls
5. Supabase auth redirect urls


____________________________________________________________________

Generate 32 byte secret: require('crypto').randomBytes(32).toString('base64').slice(0, 32)
____________________________________________________________________


Content Layer (Blog)
- npm i contentlayer next-contentlayer remark-gfm rehype-pretty-code rehype-slug rehype-autolink-headings lucide-react
- copy /Optional/ContentLayer

____________________________________________________________________

Tweet
- npm i react-parallax-tilt
- Copy /Optional/Tweet
- Make Twitter app with appropriate permissions

____________________________________________________________________

SEO

Item (H→L Priority)	Function			Written
1. Sitemap 		Allows discovery by SE		Per project
2. Semantic Tags 	Allows understanding by SE	Per file
3. Structured Schema	Allows deep understanding	Per file
4. Metadata		Allows searchability by users	Per file
5. OG			SM Thumbnails			Per item
6. Image Opt		Improves SE Ranking		Per item

____________________________________________________________________

↓ TRIGGER		table   	plpgsql   	api		<- GETS TRIGGERED
table			    x		trigger  	http-webhook
plpgsql			function	      x	          x
server			    v		 rpc		  x
____________________________________________________________________

Inferred GetServerSideProps
type ThreadData = inferRouterOutputs<AppRouter>["threads"]["joinThreadWithLinkCode"];

type Props = InferGetServerSidePropsType<typeof getServerSideProps>;

export const getServerSideProps = (async (context) => {
  return {
    props: ...
  }
}) satisfies GetServerSideProps;

____________________________________________________________________

Now its time to set up API routes (TRPC routers)
- Write all required routers
- Write requirement outline, inputs, calls, output for each router
- Use TRPC middleware

- Make Supabase RLS policies
- Add access functionality to API

____________________________________________________________________


Time Suckers
- Server side authentication with helpers and context injection
- Authentication error (strictMode)
- TRPC backend router layout
- TRPC middleware vs context injection (for user extraction)
- Request throttling (with context)


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[TRPC]
# Where is TRPC object created?			s/trpc.ts
# What is TRPC object added to?
	it is not directly added
	it has a create router fn and procedure
	create router is used to create parent router, which is added to NextApiHandler
	procedure is used to create routers
# What inputs does NextApiHandler take?		parent router, context creation fn
# Where is context creation function written?	s/trpc.ts
# Where is context creation function added?	to NextApiHandler
# Where is NextApiHandler created		p/trpc/[trpc].ts
# Where is parent router created?		s/root.ts
# Where to write new routers? 			s/routers/<name>.ts
# Where to add new routers? 			to parent router
# Where to write new middleware?		s/trpc.ts
# Where to connect middleware to procedure?	s/trpc.ts
# Where to write new procedures?		s/trpc.ts
# Where to add new procedures?			already added to TRPC object
# What is the use of procedures?		router creation

1 context → 1 parent router → 'x' routers
1 router → 'y' procedures
1 procedure → 'z' middlewares
Only 1 context for every router, but any number of middlewares

> context: attaching objects
> middleware: filtering requests (based on attached or fetched info)
> procedures: performing operations

Middleware building flow
- Make a middleware
- Add it to public procedure to create a new (restricted) procedure
- Use (restricted) procedure to create new (restricted) routers

What TRPC gives
- Server side routing
- Server side middleware
- Autocomplete
- Easy fetch calls

What to use it for
- Complex db operations, which require lots of validation ops
- Platform wide operations (e.g. get all products for homepage)
- Forced limited operations (throttling, max fetch count etc)

# Should I use client side library?
# Should I make independent api route for cookie setting?
# What should I change the inner context input type to?
# What server ops should I handle outside of trpc?
   - Authentication
   - Cookie setting
   - Next middleware, serversideprops & staticprops
   - Simple client-db calls (access based match/filter CRUD - use with ZOD)

Method 1: Minimal TRPC
> The best way to use TRPC is to try as much as possible to not use it
> Because force fitting everything into TRPC becomes a huge burden
> Just replace fetch calls with TRPC, for everything else, useQuery

Method 2: Maximal TRPC
> Perform all server operations through TRPC
> Only don't use TRPC where you can't access it (e.g. serversideprops)
> Use it for boundary operations like auth, cookie setting, db calls


		Pro			Con
Method 1	Fast dev		Messy /lib
Method 2	Uniform DX		++latency, ++serverless cost, fighting client libraries

> Zod is more important to master than TRPC, because it integrates into your work, not vice versa
> Combination of these 4 libraries in right proportions => a great product in the least time

┌──────────────────────────────────────────────┐
│  Zod -> Supabase Client -> useQuery -> TRPC  │
└──────────────────────────────────────────────┘
Zod: Pin
SB Client: Pocket Knife
useQuery: Dagger
TRPC: Sword


[Auth]
Integration flow
- Add global zus auth-state
- Add set cookie API route
- Add auth button and logic
- useEffect, []
   - Add user checker function
	- Set auth-state
   - Add supabase auth listener
	- auth-state set
   	- Cookie set
   	- Router push
   - Cleanup unsub
- Add auth-state based UI
- Add auth guard middleware

Auth setting in 4 places
✖ initial DB call
✔ user action
✔ listener
✖ effect
Use zus to store info(update with listener), don't rely on supabase client


[Templating]
Things you make
- hooks (will contain store, external calls, initialiser)
- lib
- middlewares
- routers
- context

Pattern
- Every entity (not action) in app (e.g. User, Cart) has a custom hook
- The hook can have a store, internal logic, or external API calls
- Every hook has an init function, which manages LS call, initial DB call, listener attachment
- Init functions are called by useInit hook only, not the hook itself
- If init functions are interdependent (e.g. user→cart), then waterfall init return values
- All init functions are async


^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Stripe Connect Management with Usage Based Billing and Custom Payouts

✔ Customer
	- Make a customer and store cus_id on sign up
	  > https://stripe.com/docs/api/customers/create
- Subscription
	- Make checkout session and store sub_item_id when cus_id sets up payment
	  > https://stripe.com/docs/api/checkout/sessions/create
	✖ Make+store sub_item_id when cus_id sets up payment
	  > https://stripe.com/docs/api/subscriptions/create
- Management
	- Manage with Billing Portal (update payment method, cancel sub)
	  > https://stripe.com/docs/api/customer_portal/sessions/create
	✖ Manage cancellation (and remove sub_id)
	  > https://stripe.com/docs/api/subscriptions/cancel
- Connect
	- Make+store connected_act_id when engg onboards
	  > https://stripe.com/docs/connect/express-accounts
	  > https://stripe.com/docs/api/accounts/create
	  > https://stripe.com/docs/api/account_links/create
- Usage
	- Update record on every API call (in CF KV)
	  > https://stripe.com/docs/billing/subscriptions/usage-based#report
- Payout
	- Payout on manual action by engg if amt > $10
	  > https://stripe.com/docs/api/payouts/create

____________________________________________________________________


Code Execution Strategies
- Server Calls (from front end)
- Webhook Calls
   - Stripe
   - Supabase table CRUD
- Supabase Function Triggers (within DB)

DB ↔ Server ↔ External (Stripe etc)
	|
     Client

____________________________________________________________________


Marketing Strategies
- Post a LinkedIn job for prompt engineers to drive traffic
- Make a building an AI startup vlog/blog
- Reach out to PEs on LinkedIn/Promptbase
- HN/IH/PH/Reddit
- Rebuild cutting edge tools in Promptify and make videos
- Make best AI tools and resources compilation newsletters
- Make community/jobs websites.

____________________________________________________________________


Pre Launch Settings Checklist
□ Supabase auth url
□ Provider auth urls
□ Supabase webhooks urls
□ Stripe webhooks urls
□ env variables


____________________________________________________________________


Form Logic Variants
> Checked
   - on submit		(errors by zod path)
   - dynamically	(errors in custom vars)
   - server side	(errors via alerts)
> Values Recording
   - in form		(form data via prop 'name')
   - in form customised (nested on sub)
   - custom vars 	(appended to form on sub)
> Error Reporting
   - zod field name
   - obj property name	(arrays)

• Arrays matched by property name, no need for dynamic zod names
Element names → data → validated against Schema → Error object paths acc to schema → Error paths converted to flat Map of errors → Elements have errors matching the name structure by convention


____________________________________________________________________



